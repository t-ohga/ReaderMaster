# 05_technical - 技術要件定義

## 🎯 このカテゴリで決めること

プロダクトを実現するための**技術的な基盤**を定義します：

1. **システムアーキテクチャ**: どのような構成でシステムを構築するか？
2. **技術スタック選定**: 使用する言語・フレームワーク・ライブラリは？
3. **インフラ構成**: ホスティング・ストレージ・スケーラビリティは？
4. **API設計**: システム間のインターフェースはどう設計するか？

## 📝 前提条件

**必須完了カテゴリ:**
- **04_ux_design**: UX/UI設計が完了していること
  - インタラクティブキャンバスの要件
  - オブジェクト操作のUX仕様
  - レスポンシブデザイン要件

**推奨完了カテゴリ:**
- **03_features**: 機能要件
- **02_users**: ターゲットユーザーの特性（技術リテラシー等）

あると検討がスムーズなもの:
- パフォーマンス要件（処理時間、同時接続数など）
- セキュリティ要件（データ保護、認証方式など）
- 予算とスケジュール制約

## 🎯 期待される成果物

### 各サブカテゴリの成果物

**architecture/**
- システム全体のアーキテクチャ図
- フロントエンド・バックエンド・AI/OCRエンジンの構成
- コンポーネント間の通信フロー

**tech_stack/**
- プラットフォーム選定（Web/デスクトップ）
- フロントエンドフレームワーク選定
- バックエンド技術選定
- AI/OCRライブラリ選定
- 選定理由と代替案の評価

**infrastructure/**
- ホスティング戦略
- ストレージ設計
- スケーラビリティ計画
- モニタリング・ロギング戦略

**api_design/**
- API方式選定（RESTful/GraphQL）
- エンドポイント設計
- データモデル定義
- 認証・認可方式

## 🔗 このカテゴリが影響する他のカテゴリ

### 直接影響
- **06_security**: 技術選定がセキュリティ要件に与える影響
- **07_data**: データモデルとストレージ設計の整合性
- **09_development/phases**: 技術スタックに基づく開発フェーズ計画
- **10_risks/technical**: 技術的リスクの特定と対策

### 間接影響
- **08_integration**: 外部システムとの統合方式
- **11_quality/performance**: パフォーマンス要件の実現可能性
- **11_quality/testing**: テスト戦略と技術スタックの整合性

## 📂 サブカテゴリの説明

### architecture/
**目的**: システム全体の構造を定義
- フロントエンド、バックエンド、AI/OCRエンジンの配置
- コンポーネント間の通信パターン
- データフローとイベント駆動の設計

**重要な決定**:
- モノリシック vs マイクロサービス
- クライアントサイド vs サーバーサイド処理
- リアルタイム通信の必要性

### tech_stack/
**目的**: 使用する技術の選定と評価
- プラットフォーム選択（Web優先 or デスクトップ優先）
- フロントエンド技術（React/Vue/Svelte等）
- バックエンド技術（Node.js/Python/Go等）
- AI/OCRライブラリ（Tesseract/PaddleOCR/Cloud Vision等）

**重要な決定**:
- チームのスキルセットとの整合性
- 学習曲線と開発速度のバランス
- エコシステムとコミュニティサポート

### infrastructure/
**目的**: 運用基盤の設計
- ホスティング戦略（クラウド/オンプレミス/ハイブリッド）
- ストレージ設計（画像・ドキュメント・メタデータ）
- スケーラビリティとコスト最適化
- モニタリングとログ管理

**重要な決定**:
- 初期コスト vs 運用コスト
- スケールアップ vs スケールアウト
- ベンダーロックインのリスク管理

### api_design/
**目的**: システム間インターフェースの設計
- API方式の選定（RESTful/GraphQL/gRPC）
- エンドポイント設計とバージョニング戦略
- データモデルとスキーマ定義
- 認証・認可・レート制限

**重要な決定**:
- APIの公開範囲（内部のみ/外部公開）
- リアルタイム性の要件
- エラーハンドリングとリトライ戦略

## ✅ 完了の基準

このカテゴリは以下の条件を満たせば完了です：

- [ ] すべてのサブカテゴリのドキュメントが作成された
- [ ] 技術選定の根拠が明確に記述されている
- [ ] アーキテクチャ図が作成され、コンポーネントの責務が明確
- [ ] 技術スタックの選定理由と代替案評価が完了
- [ ] インフラ構成とコスト見積もりが完了
- [ ] API設計とデータモデル定義が完了
- [ ] STATUS.mdを「完了」に更新した
- [ ] PROGRESS_TRACKER.mdを更新した
- [ ] 重要な決定をDECISION_LOG.mdに記録した

## 💡 検討のヒント

### よくある落とし穴

1. **技術優先になる**
   - ❌ 「最新のフレームワークを使いたい」
   - ✅ 「要件を満たし、チームが習熟できる技術を選ぶ」

2. **過剰設計**
   - ❌ 「将来のあらゆる拡張に対応できる複雑なアーキテクチャ」
   - ✅ 「現在の要件を満たし、段階的に拡張可能なシンプルな設計」

3. **インフラコストの見落とし**
   - ❌ 「とりあえずクラウドで全部やる」
   - ✅ 「ユーザー数とデータ量に応じたコスト試算」

### AI/OCR処理における技術選定のポイント

**クライアントサイド処理 vs サーバーサイド処理**
- **クライアント**（Tesseract.js等）
  - ✅ プライバシー保護、サーバーコスト削減
  - ❌ デバイス性能依存、精度が低い場合がある

- **サーバー**（Cloud Vision API, PaddleOCR等）
  - ✅ 高精度、デバイス非依存
  - ❌ 通信コスト、APIコスト、レイテンシ

- **ハイブリッド**
  - ✅ 軽量処理はクライアント、高精度処理はサーバー
  - ❌ 実装複雑性の増加

**インタラクティブキャンバスの技術選択**
- **Canvas API**: パフォーマンス優先、ピクセル操作
- **SVG**: ベクター操作、DOM統合
- **WebGL/Three.js**: 3D表現、高度なエフェクト
- **Fabric.js/Konva.js**: Canvas抽象化、オブジェクト管理

### このプロジェクトの技術要件（初期案）

現在のコンセプトから抽出すると：

**フロントエンド**
- インタラクティブキャンバス（Fabric.js/Konva.js候補）
- モダンフレームワーク（React/Vue/Svelte）
- レスポンシブデザイン対応

**バックエンド**
- 画像/PDF処理API
- OCR処理エンジン（クライアント/サーバーのハイブリッド検討）
- オブジェクトメタデータ管理

**インフラ**
- 画像ストレージ（S3/GCS等）
- スケーラブルなAPI基盤
- CDN配信（静的アセット）

これを起点に、各サブカテゴリで深掘りしてください。

## 🚀 次のステップ

### 推奨順序

1. **architecture/** から開始
   - システム全体像の把握
   - コンポーネント分割の決定

2. **tech_stack/** で具体化
   - 各コンポーネントの技術選定
   - 学習コストと開発速度の評価

3. **infrastructure/** で運用設計
   - ホスティング戦略
   - コスト試算

4. **api_design/** で接続仕様
   - インターフェース定義
   - データモデル設計

### 各サブカテゴリの開始方法

各サブカテゴリには個別のドキュメントがあります：
- `architecture/README.md` - アーキテクチャ設計ガイド
- `tech_stack/README.md` - 技術選定ガイド
- `infrastructure/README.md` - インフラ設計ガイド
- `api_design/README.md` - API設計ガイド

**準備ができたら**: 各サブカテゴリの`TEMPLATE.md`をコピーして作業を開始してください。

---

**重要**: 技術選定は「できること」ではなく「すべきこと」から逆算してください。要件を満たす最もシンプルな技術を選ぶことが成功への近道です。
